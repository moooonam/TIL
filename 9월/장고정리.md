# 장고 이놈 !!!!

> ### Django Intro
<br>

- 서비스 개발에 필요한 기능들을 미리 구현해서 모아놓은 것 = 프레임워크(Framework)
- Django => 파이썬으로 작성된 프레임워크
- 웹 페이지 종류
  1. 정적 웹 페이지: 서버에 미리 저장됨 HTML파일 그대로 전달된 웹 페이지
  2. 동적 웹 페이지: 사용자의 요청에 따라 웹 페이지에 추가적인 수정이 되어 클라이언트에게 전달되는 웹 페이지
- Django Design Pattern
  - MVT 패턴 
   1. Model: 응용프로그램의 데이터 구조를 정의하고 데이터베이스의 기록을 관리
   2. View: Model&Template와 관련한 로직을 처리
   3. Template:레이아웃과 화면을 처리

<br>
<hr>
<br>


> ### Django Quick start
<br>

- Django 설치
  - $ pip install django
  - $ pip freeze > requirements.txt (패키지 목록 작성)
  - $ django-admin startproject 프로젝트이름 . (프로젝트 생성)
  - $ python manage.py runserver (서버 실행)
  - $ python manage.py startapp 앱이름 (앱 생성)
- 앱 등록 : 프로젝트에서 앱을 사용하기 위해서는 settings.py에 INSTALLED_APPS 리스트에 반드시 추가해야함 (반드시 **생성후 등록**)
- 요청과 응답
  - URL-> VIEW -> TEMPLATE 순으로 작성
- View
  - HTTP 요청을 수신하고 HTTP 응답을 반환하는 함수 작성
  - Template에게 HTTP 응답 서식을 맡김
- render()
  - render(request, template_name, context)
  - 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링된 텍스트와 함꼐 응답 객체를 반환하는 함수
  1. request
   - 응답을 생성하는 데 사용되는 요청 객체
  2. template_name
   - 템플릿의 전체 이름 또는 템플릿 이름의 경로
  3. context
   - 템플릿에서 사용할 데이터(딕셔너리 타입으로 작성)

<br>
<hr>
<br>

> ### Django Template
<br>

- Variable=>{{ variable }}
  - 변수명은 영어,숫자,밑줄(_)의 조합으로 구성될 수 있으나 밑줄로는 시작 할 수 없음
  - dot(.)을 사용하여 변수 속성에 접근할 수 있음
  - render()의 세번째 인자로 {'key':value}와 같이 딕셔너리 형태로 넘겨주며, 여기서 정의한 key에 해당하는 문자열이 template에서 사용 가능한 변수명이 됨
- Filters=> {{ variable|filter }}
  - 표시할 변수를 수정할 때 사용
  - 예시 ) {{ name|lower }} name 변수를 모두 소문자로 출력
  - 60개의 built-in-template filters를 제공
  - chained가 가능하며 일부 필터는 인자를 받기도 함 {{ name|truncaterwords:30 }}
- Tags => {% tag %}
  - 출력 텍스트를 만들거나, 반복 또는 논리를 수행하여 제어 흐름을 만드는 등 변수보다 복잡한 일들을 수행
  - 일부 태그는 시작과 종료 태그가 필요 {% if %}{{% endif %}}
  - 약 24개의 built-in template tags를 제공
- Comments(주석) => {# #} 여러줄은 {% comment %}{% endcomment %}
- 템플릿 상속 (Template inheritance)
  - 템플릿 상속은 기본적으로 코드의 재사용성에 초점을 맞춤
  - {% extends 'base.html %} 부모 템플릿(base.html)을 확장한다는 것을 알림
  - {% block content %}{% endblock content %} 내용 작성
- 추가 템플릿 경로 추가하기
  - base.html 위치를 앱 안의 template 디렉토리가 아닌 프로젝트 최상단의 templates 디렉토리 안에 위치하고 싶다면 
  - 기본 template 경로가 아닌 다른 경로를 추가하기위해 settings.py 에 TEMPALTES 에 'DIRS' : [BASE_DIR / 'templates',]를 추가



<br>
<hr>
<br>


> ### Sending and Retrieving form data
<br>

- HTML form element
  - 데이터가 전송되는 방법을 정의
  - 웹에서 사용자 정보를 입력하는 여러방식(text, button, submit 등)을 제공하고, 사용자로부터 할당된 데이터를 서버를 전송하는 역할을 담당 
  - 데이터를 어디(action)로 어떤 방식(method)으로 보낼지
  - 핵심속성
    - action
    - method
- HTML form's attributes
  1. action
   - 입력 데이터가 전송될 URL을 지정
   - 데이터를 어디로 보낼 것인지 지정하는 것이며 이 값은 반드시 유효한 URL이어야 함
   - 만약 이 속성을 지정하지 않으면 데이터는 현재 form이 있는 페이지의 URL로 보내짐
  2. method
   - 데이터를 어떻게 보낼 것인지 정의
   - 입력 데이터의 HTTP request methods를 지정
   - HTML form 데이터는 오직 2가지 방법으로만 전송 할 수 있는데 바로 GET 방식과 POST 방식
- Form의 특성
  - ```<input type="">```:tpye 속성에 따라 동작 방식이 달라짐 기본값은 "text"
  - 핵심 속성 **name** 
    - name 속성에 설정된 값을 서버로 전송하고 서버는 name값을 통해 데이커 값에 접근할 수 있음
    - GET 방식에서는 URL에서 '?key=value&key=value/' 형식으로 데이터를 전달함
- HTTP request methods
  - HTTP: HTML 문서와 같은 리소스(데이터,자원)들을 가져올 수 있도록 해주는 프로토콜(규칙,규약)
  - 웹에서 이루어지는 모든 데이터 교환의 기초
  - 리소스에 대한 행위를 정의함
  - **GET**
    - 서버로부터 정보를 조회하는데 사용
    - 데이터를 가져올 때만 사용해야 함
    - 데이터를 서버로 전송할 때 Query String Parameters를 통해 전송
      - 데이터는 URL에 포함되어 서버로 보내짐 
- Retrieving the Data(server)  
  - 모든 요청 데이터는 request에 들어있다.
  - request.GET 은 딕셔너리 형태로 정보를 받기 때문에 request.GET.get('name')을 적용해 데이터를 받을 수 있다.


<br>
<hr>
<br>


> ### Django URLs
<br>

- Trailing URL Slashes
  - Django 는 URL 끝에 '/'가 없다면 자동으로 붙여줌
  - 모든 주소가 '/'로 끝남
  - 그러나 모든 프레임 워크가 이렇게 동작하는 것은 아님
  - [참고] URL 정규화
    - 복수의 페이지에서 같은 콘턴츠가 존재하는 것을 방지하기 위함
- Variable routing
  - 필요성 : 템플릿의 많은 부분이 중복되고, 일부분만 변경되는 상황에서 비슷한 URL과 템플릿을 계속해서 만들어야 할까?
  - variable routing
    - URL주소를 변수로 사용하는 것을 의미
    - URL의 일부를 변수로 지정하여 view함수의 인자로 넘길 수 있음
- 변수는 '<>'에 정의하며 view함수의 인자로 할당됨
- 기본 타입은 str이고 주로 str, int로 쓰임
  
```py
#urls.py
path('hello/<name>/', views.hello),

# articles/views.py
def hello(request, name):
 context = {
   'name':name,
  }
 return render(request, 'hello.html', context)

#articles/templates/hello.html
{% extends "base.html" %}

{% block content %}
  <h1>만나서 반가워요</h1>
  <h2>{{name}}님</h2>
{% endblock content %}
```

- App URL mapping
  - 앱이 많아지면 앱마다 url을 따로 만들어서 관리하는것이 좋음
  ```py
  # app/urls.py
  from . import views

  urlpatterns =[
    path('index/', views.index),
  ]

  #pjy/urls.py
  from django.urls import path, include

  urlpatterns =[
    path('articles/', include('articles.urls')),
  ]
  ```
 - include되는 앱의 urls.py에 urlpatterns가 작성되어 있지 않다면 에러가 발생함 빈 상태를 표현하고 싶다면 urlpatterns =[] 이런식으로 빈 리스트 만들어야함
  
- 만약 url 이름 바꾸면 모든 html의 경로를 바꿔야할가? 당근 아님 
  - path함수의 name인자를 정의해주고 URL태그{% url '' %}를 사용해서 path에서 작성한 name 을 사용할 수 있음


<br>
<hr>
<br>


> ### Namespace

- URL namespace를 사용하면 서로 다른 앱에서 동일한 URL 이름을 사용하는 경우데 이름이 지정된 URL을 고유하게 사용 할 수 있음
- app_name attribute를 작성해 URL namespace를 설정

```py
# articles/urls.py
app_name = 'articles'
urlpatterns = [
  어쩌고 저쩌고
]
```
- URL tag의 변화
  - {% url 'index' %} => {% url 'articles:index' %}
- 주의!!: app_name을 지정한 이후에는 url태그에서 반드시 app_name:url_name 형태로만 사용해야함 그렇지 않으면 에러가 발생

- Template namespace
  - Django는 기본적으로 app_name/templates/경로에 있는 templates 파일들만 찾을수 있음
  - Django templates의 기본 경로에 app과 같은 이름의 폴더를 생성해 폴더 구조를 app_name/templates/app_name/ 형태로 변경
  - 폴더 구조 변경 후 변경된 경로로 해당하는 모든 부분을 수정
  - ```py
    # articles/views.py

    return render(request, 'articles/index.html')
    ```
<br>
<hr>
<br>

> ### Django Model
<br>

- Database
  - 체계화된 데이터의 모임
  - 검색 및 구조화 같은 작업을 보다 쉽게 하기 위해 조직화된 데이터를 수집하는 저장 시스템
  - 스키마(Schema)
    - 뼈대(Structure)
    - 데이터베이스에서 자료의 구조, 표현 방법,관계등을 정의한 구조
    - column: 데이터의 이름
    - datatype: int,text .....
  - 테이블(table)
    - 필드와 레코드를 사용해 조직된 데이터 요소들의 집합(관계(Relation)라고도 부름)
    1. 필드(field) : 속성, 컬럼(Column)
    2. 레코드(record) : 튜플, 행(Row)
  - PK(Primart Key)
    - 기본 키
    - 각 레코드의 교유한 값(식별자로 사용)
    - 기술적으로 **다른 항목과 절대로 중복되어 나타날 수 없는 단일값을 가짐**
  - 쿼리(Query)
    - 데이터를 조회하기 위한 명령어를 일컬음
    - "Query를 날린다" => "데이터베이스를 조작한다."
- Model
  - Django는 Model을 통해 데이터에 접속하고 관리
  - models.py 작성
    - 모델 클래스를 작성하는 것은 데이터베이스 테이블의 스키마를 정의 하는 것
    - "모델 클래스 == 테이블 스키마"
    ```py
    # articles/models.py
    # 각 모델은 django.models.Model의 서브 클래스임
    # models 모듈의 Model 클래스를 상속받아서 구성된다.
    class Article(models.Model):
      title = models.CharField(max_lenth=10)
      content = models.TextField()

    # id컬럼은 테이블 생성할때 Django가 자동으로 생성
    ```
  - Django Model Field
    - Django는 모델 필드를 통해 테이블의 필드에 저장할 데이터 유형을 정의
    - 데이터 유형에 따라 다양한 모델 필드를 제공
      - DataField(), CharField(), IntegerField()등..
- Migrations
  - 모델에 대한 청사진을 만들고 이를 통해 테이블을 생성하는 일련의 과정
  - Django가 모델에 생긴 변화(필드추가, 모델삭제 등)을 DB에 반영하는 방법
  - makemigrations
    - 모델을 작성 혹은 변경한 것에 기반한 새로운 migration을 만들 때 사용
    - $ python manage.py makemigrations
    - 명령어 실행 후 migrations/0001_initial.py가 생김
    - "파이썬으로 작성된 설계도"
  - migrate
    - makemigrations로 만든 설계도를 실제 db.sqlite3 DB파일에 반영하는 과정
    - "모델과 DB의 동기화"
    - $ python manage.py migrate
- ORM
  - 설계도는 파이썬으로 작성되었고 DB는 SQL만 알아 들을수 있다는데 어떻게 이 설계도를 이해하고 동기화를 하냐? => 이 과정에서 중간에 해석을 담당하는 것이 **ORM**
  - Object-Relationmal-Mapping
  - 객체 지향 프로그래밍에서 데이터베이스를 연동할 때, 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법
  - Django는 내장 Django ORM을 사용
  - 장점
    - SQL을 잘 알지 못해도 객체지향 언어로 DB조작이 가능
    - 객체 지향적 접근으로 인한 **높은 생산성**
  - 단점
    - ORM만으로 완전한 서비스를 구현하기 어려운 경우가 있음

<br>
<hr>
<br>

> ### QuerySet API
<br>

- Database API
  - Django가 기본적으로 ORM을 제공함에 따른 것으로 DB를 편하게 조작할 수 있도록 도움
- Database API 구문
![ㅇㄹㅇ](https://velog.velcdn.com/images%2Fswhan9404%2Fpost%2Fe2610e96-e6cc-43da-b78c-d60ee2396101%2Fimage-20210310110854053.png)
- "objects" manager
  - DB를 Python class로 조작할 수 있도록 여러 메서드를 제공하는 manager"
- Query
  - 데이터베이스에 특정한 데이터를 보여 달라는 요청
  - QuerySet:요청한 데이터를 QuertSet이라는 자료 형태로 변환하여 우리에게 전달
    - 순회가능, 필터,정렬등 사용 가능, 단일 객체 반환시에는 모델의 인스턴스로 반환

<br>
<hr>
<br>

> ### QuerySet API를 이용한 CRUD 
<br>

- CREATE
  ```py
  # 1
  article = Article()
  article.title = "제목을 작성"
  article.content = "내용을 작성"
  article.save()   # save method를 호출해야 DB에 저장된다.

  # 2
  article = Article(title="제목을 작성", content = "내용을 작성")
  article.save()
  # 보통 이 2번째 방법을 씀. 3번째 방법이 더 간단해 보이지만  데이터가 저장되기 전에 유효성 검사를 하고 저장하려고 이방법을 씀

  # 3
  Article.object.create(title="제목을 작성". content="내용을 작성")
  ```
- READ
  ```py
  # 1
  Article.objects.all() # 전체 데이터 조회

  # 2
  Article.objects.get(pk=1) #pk 처럼 고유성을 보장하는 조회에서 사용해야함

  # 3
  Article.objects.filter(content="dj") # 필터에 해당하는 결과에 따른 queryset 을 반환

  # 주의 : filter는 조회결과가 없거나 1개여도 QuerySet을 반환한다
  ```
- UPDATE
    ```py
  # update의 순서는 조회 -> update -> 저장

    # 1. 조회
    article = Article.objects.get(pk=1)
    # 2. update
    article.title = "수정할 제목"
    # 3. 저장
    article.save()
    ```
- DELETE
  ```py
  # delete의 순서는 조회 -> 삭제

  # 1. 조회
  article = Article.objects.get(pk=1)
  # 2. 삭제
  article.delete()
  ```
<br>
<hr>
<br>

> ### CRUD with view functions
<br>

- CREATE
  - Django shortcut function -"redirect()"
    - 인자에 작성된 곳으로 요쳥을 보냄
    - 사용 가능한 인자
    1. view name(URL pattern name)
    ```py
    return redirect('articles:index')
    ```
    2. absolute or relative URL
    ```py
    return redirect('/articles/')
    ```
  - HTTP response status code
  1. Informational responses(1XX)
  2. Successful responses(2XX)
  3. Redirection messages(3XX)
  4. Client error responses(4xx)
  5. Server error responses(5xx)
  - HTTP request method
    - **GET**
    - 특정 리소스를 가져오도록 요철할 때 사용
    - 반드시 데이터를 가져올 때만 사용해야 함
    - DB에 변화를 주지 않음
    - CRUD에서 R역할을 담당
    - **POST** 
    - 서버로 데이터를 전송할 때 사용
    - 서버에 변경사항을 만듦
    - CRUD에서 C/U/D 역할을 담당
  - [참고] 403 Forbidden
    - 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미
    - 서버에 요청은 도달했으나 서버가 접건을 거부할 때 반환됨
  - CSRF
    - Cross-Site-Request-Forgery
    - "사이트 간 요청 위조"
    - 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹페이지를 보안에 취약하게 하거나 수정, 삭제 등의 잡업을 하게 만드는 공격방법
  - CSRF 공격 방어
    - "Security Token 사용 방식(CSRF Token)"
    - 사용자의 데이터에 임의의 난수 값을 부여해 매 요청마다 해당 나수 값을 포함시켜 전송 시키도록 함
    - 일반적으로 데이터에서 변경이 가능한 POST,PATCH,DELETE Method등에 적용

<br>
<hr>
<br>

> ### Django Form

<br>

- 개요
  - 지금까지는 HTML form과 input 태그를 이용해서 사용자의 데이터를 받았다
  - 하지만 이중에서는 비정상적이거나 악의적인 요청이 있을 수 있다
  - 이처럼 사용자가 입력한 데이터가 우리가 원하는 데이터 형식에 맞는지에 대한 <span style="background-color:#FAF4C0">유효성 검증</span>이 필요하다
  - Django는 Form을 이용해서 **유효성 검사**를 단순화하고 자동화할 수 있다.
  - 
- The Django Form Class
  - From Class 선언
  - Form Class를 선언하는 것은 Model Class를 선언하는 것과 비슷하다
  - (비슷한 이름의 필드 타입을 많이 가지고 있지만 이름만 같을뿐 같은 필드는 아님)
  - Model과 마찬가지로 상속을 통해 선언(forms 라이브러리의 Form 클래스를 상속받음)
  - 앱폴더에 forms.py를 생성 후 ArticleForm Class선언
  - (파일 이름이 달라도 되고, 다른곳에 작성해도 되나, 더 나은 유지보수의 관점 그리고 관행적으로 forms.py 파일 안에 작성한는 것을 권장)
  ```py
  #articlse/forms.py
  from django import forms

  class ArticleForm(forms.Form):
      title = forms.CharField(max_length=20)
        # form 에서는 TextField가 없다! CharField
      content = forms.CharField()


  #articles/views.py
  from .forms import ArticleForm

  def new(request):
      form = ArticleForm()
      context = {
          'form':form,
      }
      return render(request, 'articles/new.html', context)
  
  #articles/templates/new.html
  {% extends 'base.html' %}

  {% block content %}
    <h1>NEW</h1>
    <form action="{% url 'articles:create' %}" method="POST">
      {% csrf_token %}
      {{  form.as_p  }}
      # 각 필드를 <p>태그로 감싸서 렌더링 하기 위해서 이렇게 작성한다.
      <input type="submit">
    </form>
    <hr>
    <a href="{% url 'articles:index' %}">뒤로가기</a>
  {% endblock content %}
  ```   
  - Form rendering options
  1. as_p()
      - 각 필드가 단락(\<p> 태그)으로 감싸져서 렌더링
  2. as_ul()
      - 각 필드가 목록항목(\<li>태그)으로 감싸져서 렌더링
   - 