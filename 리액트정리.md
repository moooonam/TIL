# 리액트

> ### 시작하기
- npx create-react-app 앱이름
- npm start

> ### 막 정리

- JSX문법이래
  - JavaScript + XML/HTML
  - JSX 장점
    - 코드가 간결해짐
    - 가독성이 좋아짐 (유지보수 좋음)
    - 보안 위험을 줄임
- react elements
  - immutable
- props => Component의 속 재료
  - 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체 
  - read-only => 값을 변경할 수 없다
- Component 이름은 항상 대문자로 시작해야 한다!!
- 태그 안에 class 대신 className 을 씀 
- 데이터 바인딩 할때 중괄호 씀 {}
- 데이터는 변수에 넣거나 state에 넣거나
  - state는 변수 대신 쓰는 데이터 저장 공간
  - useState()를 이용해 만들어야함 (import해주고)
  - let [글제목, 글제목변경] = useState('나는 제목') 이런식으로 사용
  - state를 사용하는 이유는 웹이 App처럼 동작하게 만들고 싶어서
  - state 변경은 두번째 변수를 사용

<br>

- useEffect()
  - useEffect(이펙트 함수, 의존성 배열)
  - 컴포넌트가 마운트 된 이후, 의존성 배열에 있는 변수들 중 하나라도 값이 변경되었을 때 실행됨
  - 의존성 배열에 빈 배열([])을 넣으면 마운트와 언마운트시에 단 한 번씩만 실행됨
  - 의존성 배열 생략 시 컴포넌트 업데이트 시마다 실행됨

<br>

- useMemo()
  
```js
const memoizedValue = useMemo(
  () => {
    // 연산량이 높은 작업을 수행하여 결과를 반환
    return computeExpensiveValue(의존성 변수1, 의존성 변수2);
  },
  [의존성 변수1, 의존성 변수2]
);
```

<br>

- useCallback()

```js
const memoizedCallback = useCallback(
  () => {
    doSomething(의존성 변수1, 의존성 변수2);
  },
  [의존성 변수1, 의존성 변수2]
);
```

- 동일한 역할을 하는 두 줄의 코드
- useCallbakc(함수, 의존성 배열)
- useMemo(() => 함수, 의존성 배열)

<br>

- useRef()
- const refContainer = useRef(초깃값)

<br>

- Hook 규칙
  - Hook은 무조건 최상위 레벨에서만 호출해야 한다.
  - Hook은 컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 한다.
  - 리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.

<br>

- Custom Hook