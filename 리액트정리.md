# 리액트
  
> ### 시작하기
- npx create-react-app 앱이름
- npm start

> ### 막 정리

- JSX문법이래
  - JavaScript + XML/HTML
  - JSX 장점
    - 코드가 간결해짐
    - 가독성이 좋아짐 (유지보수 좋음)
    - 보안 위험을 줄임
- react elements
  - immutable
- props => Component의 속 재료
  - 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체 
  - read-only => 값을 변경할 수 없다
- Component 이름은 항상 대문자로 시작해야 한다!!
- 태그 안에 class 대신 className 을 씀 
- 데이터 바인딩 할때 중괄호 씀 {}
- 데이터는 변수에 넣거나 state에 넣거나
  - state는 변수 대신 쓰는 데이터 저장 공간
  - useState()를 이용해 만들어야함 (import해주고)
  - let [글제목, 글제목변경] = useState('나는 제목') 이런식으로 사용
  - state를 사용하는 이유는 웹이 App처럼 동작하게 만들고 싶어서
  - state 변경은 두번째 변수를 사용

<br>

- useEffect()
  - useEffect(이펙트 함수, 의존성 배열)
  - 컴포넌트가 마운트 된 이후, 의존성 배열에 있는 변수들 중 하나라도 값이 변경되었을 때 실행됨
  - 의존성 배열에 빈 배열([])을 넣으면 마운트와 언마운트시에 단 한 번씩만 실행됨
  - 의존성 배열 생략 시 컴포넌트 업데이트 시마다 실행됨

<br>

- useMemo()
  
```js
const memoizedValue = useMemo(
  () => {
    // 연산량이 높은 작업을 수행하여 결과를 반환
    return computeExpensiveValue(의존성 변수1, 의존성 변수2);
  },
  [의존성 변수1, 의존성 변수2]
);
```

<br>

- useCallback()

```js
const memoizedCallback = useCallback(
  () => {
    doSomething(의존성 변수1, 의존성 변수2);
  },
  [의존성 변수1, 의존성 변수2]
);
```

- 동일한 역할을 하는 두 줄의 코드
- useCallbakc(함수, 의존성 배열)
- useMemo(() => 함수, 의존성 배열)

<br>

- useRef()
- const refContainer = useRef(초깃값)

<br>

- Hook 규칙
  - Hook은 무조건 최상위 레벨에서만 호출해야 한다.
  - Hook은 컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 한다.
  - 리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.

<br>

- Custom Hook


## 생활코딩
<hr>

### 시작하기

- npx create-react-app 앱이름
- npm start
- npm run bulid
  - 빌드하기 => 빌드에 최적화되게 만듬
- npx serve -s bulid 
  - 빌드된거 실행

### 컴포넌트 만들기
- 리액트의 사용자 정의 태그(컴포넌트)를 만들때는 반드시 대문자로 시작해야함

### props
- 리액트에서는 속성값을 props라함
```js
// import logo from './logo.svg';
import './App.css';
function Header(props) {
  return (
    <header>
      <h1><a href="/">{props.title}</a></h1>
    </header>
  )
}
function Nav(props) {
  const lis = [
    <li><a href="/read/1">html</a></li>,
    <li><a href="/read/2">css</a></li>,
    <li><a href="/read/3">js</a></li>
  ]
  for(let i=0; i<props.topics.length; i++){
    let t = props.topics[i];
    lis.push(<li key={t.id}><a href={'/read/'+t.id}>{t.title}</a></li>)
  }
  return (
    <nav>
      <ol>
        {lis}
      </ol>
    </nav>
  )
}
function Article(props) {
  return(
    <article>
      <h2>{props.title}</h2>
      {props.body}
    </article>
  )
}
function App() {
  const topics = [
    {id:1, title:"html", body:"heml is ..."},
    {id:2, title:"css", body:"css is ..."},
    {id:3, title:"javascript", body:"javascript is ..."}
  ]
  return (
    <div className="App">
      <Header title="REACT"></Header>
      <Nav topics={topics}></Nav>
      <Article title="Welcome" body="Hello"></Article>
    </div>
  );
}

export default App;

```

### 이벤트


### state
- state를 사용하는 이유는 일반 변수와 달리 "값이 변경되면 자동으로 변경된 데이터가 설정된 HTML을 렌더링 해준다." 이다.
즉, 일반 변수의 변경된 값이 적용된 사이트를 보기 위해서는 새로고침 이 필요하지만 state 를 사용하면 그럴 필요가 없다는 것이다!
그래서 state 방식을 사용한 값 저장은 자주 변경되는 데이터(제목 등)를 저장할 때 사용된다.
- state 값은 직접 변경이 불가능하며, 반드시 변경을 시킬 수 있는 함수를 사용하여 데이터를 변경해야한다.

- useState
```js
import { useState } from "react";
function App() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const onSubmit = (event) => {
    event.preventDefault()
    console.log(username, password)
  };
  return (
    <div className="App">
      <form onSubmit={onSubmit}>
        <input
          placeholder="Username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <br />
        <input
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <br />
        <button type="submit">Login</button>
      </form>
    </div>
  );
}

export default App;
```